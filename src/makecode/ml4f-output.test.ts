/**
 * @vitest-environment jsdom
 */
/**
 * (c) 2024, Center for Computational Thinking and Design at Aarhus University and contributors
 *
 * SPDX-License-Identifier: MIT
 */
import { CompileResult } from "compiler";
import { writeFileSync } from "fs";
import { compileModel, EvalData, EvalSample } from "ml4f";
import { prepareFeaturesAndLabels, trainModel } from "../ml";
import { GestureData } from "../model";
import { getAutogeneratedTs } from "./generate-custom-scripts";
// Change the file path to use different datasets.
import trainingData from "../test-fixtures/microbit-AI-activity-timer-data-log-mth-1s.json";

const fixUpTestData = (data: Partial<GestureData>[]): GestureData[] => {
  data.forEach((action) => (action.icon = "Heart"));
  return data as GestureData[];
};

function flattenSample(s: EvalSample) {
  const res: number[] = [];
  const rec = (v: unknown) => {
    if (Array.isArray(v)) v.forEach(rec);
    else if (typeof v == "number") res.push(v);
    else throw new Error("invalid input");
  };
  rec(s);
  return res;
}

function ml4fExecute(cres: CompileResult, data: EvalData): Float32Array {
  const result: Float32Array = new Float32Array(
    data.x.length * data.y[0].length
  );
  let offset = 0;
  data.x.forEach((x) => {
    const predProb = cres.execute(flattenSample(x));
    predProb.forEach((value) => {
      result.fill(value, offset, offset + 1);
      offset++;
    });
  });
  return result;
}

test("spits out files useful for testing", async () => {
  const trainingResult = await trainModel({
    data: fixUpTestData(trainingData as GestureData[]),
  });
  if (trainingResult.error) {
    return;
  }
  const tensorFlowModel = trainingResult.model;

  // Get filter output or testing data from training data.
  const { features, labels } = prepareFeaturesAndLabels(
    trainingData as GestureData[]
  );
  const testingData = {
    x: features,
    y: labels,
  };

  const numDimensions = labels[0].length;

  const ml4fCompileResult = compileModel(tensorFlowModel, {});
  const ml4fPredictionResult = ml4fExecute(ml4fCompileResult, testingData);

  const ml4fPredictionResultArry = Array.from(ml4fPredictionResult);

  const ml4fOutput = [];
  for (let i = 0; i < ml4fPredictionResultArry.length; i += numDimensions) {
    if (i + numDimensions > ml4fPredictionResultArry.length) {
      break;
    }
    ml4fOutput.push(ml4fPredictionResultArry.slice(i, i + numDimensions));
  }

  // Edit these to create the correct model header in for the model blob in autogenerated.ts
  // staging/release branch current settings: samples_period = 25; samples_length = 80;
  // one second branch current settings: samples_period = 24; samples_length = 41;
  // half time branch current settings: samples_period = 24; samples_length = 38;
  const samples_period = 24;
  const samples_length = 41;

  const autogeneratedFile = getAutogeneratedTs(
    trainingData as GestureData[],
    tensorFlowModel,
    samples_period,
    samples_length
  );

  // Write output files to root of project.
  writeFileSync("ml4f-output.json", JSON.stringify(ml4fOutput));
  writeFileSync("filter-output.json", JSON.stringify(testingData));
  writeFileSync("autogenerated.ts", autogeneratedFile);
});
