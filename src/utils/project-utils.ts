import { LayersModel } from "@tensorflow/tfjs";
import camelCase from "lodash.camelcase";
import upperFirst from "lodash.upperfirst";
import { Gesture } from "../hooks/use-gestures";
import {
  generateCustomJson,
  generateCustomTs,
  generateMainScript,
} from "./create-makecode-files";

const filenames = {
  main: "main.ts",
  blocks: "main.blocks",
  autogenerated: "autogenerated.ts",
  data: "data.json",
  pxt: "pxt.json",
  readme: "README.md",
};

const defaultPxtJson = {
  name: "Untitled",
  description: "",
  dependencies: {
    core: "*",
    microphone: "*",
    radio: "*", // needed for compiling
    "Machine Learning POC":
      "github:microbit-foundation/pxt-ml-extension-poc#459209940adf7334a694002f98a44a22a3a30e29",
  },
  files: Object.values(filenames),
};

export const generateProject = (
  gestures: Gesture[],
  model: LayersModel | undefined
) => {
  // const useableGestures = model ? gestures : [];
  const useableGestures = gestures;
  return {
    text: {
      [filenames.pxt]: JSON.stringify(defaultPxtJson),
      [filenames.readme]: "",
      [filenames.main]: generateMainScript(useableGestures, "javascript"),
      [filenames.blocks]: generateMainScript(useableGestures, "blocks"),
      [filenames.autogenerated]: model
        ? generateCustomTs(useableGestures, model)
        : "",
      [filenames.data]: generateCustomJson(gestures),
    },
  };
};

export const updateProjectFiles = (
  gestures: Gesture[],
  model: LayersModel | undefined
) => {
  const useableGestures = model ? gestures : [];
  return {
    [filenames.autogenerated]: model
      ? generateCustomTs(useableGestures, model)
      : "",
    [filenames.data]: generateCustomJson(gestures),
  };
};

export interface ActionName {
  actionLabel: string;
  actionVar: string;
}

const sanitizeActionVar = (input: string) =>
  input
    .replace(/[^\p{L}\p{N}_$\s]/gu, "")
    .replace(/^(\s|\p{N})+/gu, "")
    .trim();

const sanitizeActionLabel = (input: string) => input.replace(/"/g, "'");

export const actionNamesFromLabels = (actionLabels: string[]): ActionName[] => {
  const actionNames: ActionName[] = [];
  actionLabels.forEach((actionLabel, i) => {
    const sanitizedLabel = sanitizeActionVar(actionLabel);
    let actionVar = upperFirst(camelCase(sanitizedLabel));
    if (!actionVar) {
      actionVar = `Event`;
    }
    while (actionNames.map((an) => an.actionVar).includes(actionVar)) {
      actionVar += i;
    }
    actionNames.push({
      actionLabel: sanitizeActionLabel(actionLabel),
      actionVar,
    });
  });
  return actionNames;
};
