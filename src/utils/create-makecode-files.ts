/**
 * (c) 2024, Center for Computational Thinking and Design at Aarhus University and contributors
 *
 * SPDX-License-Identifier: MIT
 */

import { compileModel } from "ml4f";
import { generateBlob } from "@microbit-foundation/ml-header-generator";
import { ActionName, actionNamesFromLabels } from "./project-utils";
import { LayersModel } from "@tensorflow/tfjs";
import { mlSettings } from "../ml";
import { Gesture } from "../hooks/use-gestures";

export interface OnGestureRecognisedConfig {
  name: string;
  iconName: string;
}

interface BlockPos {
  x: number;
  y: number;
}

const onMLEventBlock = (name: string, children: string, pos: BlockPos) => `
  <block type="ml_on_event_start" x="${pos.x}" y="${pos.y}">
    <field name="event">ml.event.${name}</field>
    <statement name="HANDLER">
      ${children}       
    </statement>
  </block>
`;

type Language = "blocks" | "javascript";

interface LanguageStatements {
  wrapper: (children: string) => string;
  showLeds: (ledPattern: string) => string;
  showIcon: (iconName: string) => string;
  clearDisplay: () => string;
  onMLEvent: (name: string, children: string, _pos: BlockPos) => string;
}

const statements: Record<Language, LanguageStatements> = {
  javascript: {
    wrapper: (children) => children,
    showLeds: (ledPattern) => `basic.showLeds(\`${ledPattern}\`)`,
    showIcon: (iconName) => `basic.showIcon(IconNames.${iconName})`,
    clearDisplay: () => "basic.clearScreen()",
    onMLEvent: (name, children) => {
      return `ml.onStart(ml.event.${name}, function () {${children}})`;
    },
  },
  blocks: {
    wrapper: (children) =>
      `<xml xmlns="https://developers.google.com/blockly/xml">${children}</xml>`,
    showLeds: (ledPattern) =>
      `<block type="device_show_leds"><field name="LEDS">\`${ledPattern}\`</field></block>`,
    showIcon: (iconName) =>
      `<block type="basic_show_icon"><field name="i">IconNames.${iconName}</field></block>`,
    clearDisplay: () => `<block type="device_clear_display"></block>`,
    onMLEvent: onMLEventBlock,
  },
};

const onMLEventChildren = (
  s: LanguageStatements,
  { iconName }: OnGestureRecognisedConfig
) => {
  return iconName ? s.showIcon(iconName) : "";
};

const getMakeCodeGestureConfigs = (gs: Gesture[]) => {
  const actionNames = actionNamesFromLabels(gs.map((g) => g.name));
  return gs.map((g, idx) => ({
    name: actionNames[idx].actionVar,
    iconName: g.icon,
  }));
};

export const generateMainScript = (gs: Gesture[], lang: Language) => {
  const configs = getMakeCodeGestureConfigs(gs);
  const s = statements[lang];
  const initPos = { x: 0, y: 0 };
  return s.wrapper(`
  ${configs
    .map((c, idx) =>
      s.onMLEvent(c.name, onMLEventChildren(s, c), {
        x: initPos.x,
        y: initPos.y + idx * 350,
      })
    )
    .join("\n")}  `);
};

// Autogenerated code and dataset.json.
const createMlEvents = (actionNames: ActionName[]) => {
  let code = "";
  actionNames.forEach((an, idx) => {
    const stringValue = JSON.stringify(an.actionLabel);
    code += `    //% fixedInstance block=${stringValue}\n`;
    code += `    export const ${an.actionVar} = new MlEvent(${
      idx + 2
    }, ${stringValue});\n`;
  });
  return code;
};

const createEventListeners = (actionNames: ActionName[]) => {
  actionNames.unshift({
    actionLabel: "unknown",
    actionVar: "Unknown",
  });
  const totalActions = actionNames.length;
  let code = "";
  for (let i = 0; i < totalActions; i++) {
    code += `  control.onEvent(MlRunnerIds.MlRunnerInference, ${
      i + 1
    }, () => {\n`;
    code += `    maybeUpdateEventStats(event.${actionNames[i].actionVar});\n`;
    code += `  });\n`;
  }
  return code;
};

const arrayBufferToHexString = (input: Uint8Array): string =>
  Array.from(input, (i) => i.toString(16).padStart(2, "0"))
    .join("")
    .toUpperCase();

export const generateCustomTs = (gs: Gesture[], m: LayersModel) => {
  const customHeaderBlob = generateBlob({
    samples_period: 25,
    samples_length: 80,
    sample_dimensions: 3,
    actions: gs.map((g) => ({
      label: g.name,
      threshold: g.requiredConfidence ?? mlSettings.defaultRequiredConfidence,
    })),
  });
  const headerHexString = arrayBufferToHexString(
    new Uint8Array(customHeaderBlob)
  );
  const { machineCode } = compileModel(m, {});
  const modelHexString = arrayBufferToHexString(machineCode);
  const actionNames = actionNamesFromLabels(gs.map((g) => g.name));

  return `// Auto-generated. Do not edit.
namespace ml {
  export namespace event {
${createMlEvents(actionNames)}
  }
    
  events = [event.Unknown,${actionNames
    .map((an) => `event.${an.actionVar}`)
    .join(",")}];
    
${createEventListeners(actionNames)}
  getModelBlob = (): Buffer => {
    const result = hex\`${headerHexString + modelHexString}\`;
    return result;
  };
}

// Auto-generated. Do not edit. Really.
`;
};

export const generateCustomJson = (gs: Gesture[]) => {
  return JSON.stringify(
    gs.map((g) => ({
      ID: g.ID,
      name: g.name,
      numRecordings: g.recordings.length,
      requiredConfidence: g.requiredConfidence,
    }))
  );
};
